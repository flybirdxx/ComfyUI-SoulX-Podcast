规则1：上下文优先 (Context First)

指令："在编写任何代码前，必须首先分析 soulx-podcast 仓库中已有的文件（特别是 models/soulxpodcast.py, utils/infer_utils.py, utils/dataloader.py），以理解原始实现逻辑。"

目的：减少"重复造轮子"。AI 必须复用 soulx-podcast 的现有逻辑，而不是从头幻想。

规则2：增量开发 (Incremental Development)

指令："严格遵循 '开发文档' 中的三节点架构（Loader, Parser, Generator）。每次只专注于实现一个节点的功能。禁止在一个节点里实现所有功能。"

目的：减少"重复修改一处代码"。将复杂系统分解，使每个节点职责单一，易于调试。

规则3：复用优于重写 (Adapt, Don't Rewrite)

指令："当需要实现一个功能时（例如 'Suno特征提取'），优先从 soulx-podcast/utils/dataloader.py 中 '移植' __getitem__ 的相关代码，而不是自己重写 mel_spectrogram 或 onnxruntime 的调用逻辑。"

目的：保证功能一致性，减少幻觉。

规则4：遵循 ComfyUI 规范 (ComfyUI Standards)

指令："所有节点代码必须包含 INPUT_TYPES, RETURN_TYPES, FUNCTION, CATEGORY 和 NODE_CLASS_MAPPINGS。数据传递必须通过 ComfyUI 的标准类型（如 AUDIO, STRING, INT, FLOAT）或自定义的 TYPE（如 SOULX_MODEL, PODCAST_INPUT）。"

目的：确保代码可集成。

规则5：处理复杂状态 (State Management)

指令："对于播客的多轮对话历史（forward_longform 中的循环和上下文管理），必须将其封装在 PODCAST_INPUT 或 SOULX_MODEL 这样的可传递对象中，而不是依赖全局变量或在 FUNCTION 内部进行复杂的循环。"

目的：使流程可控。在 ComfyUI 中，（带 KSampler 的）流程通常是无状态的，或者状态是通过 LATENT 这样的对象传递的。我们需要模拟这一点。

规则6：依赖明确 (Dependency First)

指令："在实现一个节点（如 SoulXPodcastInputParser）之前，必须先列出它需要的所有外部依赖（如 s3tokenizer, onnxruntime）和内部函数调用（如 audio_volume_normalize），并确保这些依赖已在 SoulXPodcastLoader 中加载或已在 utils 中导入。"

目的：防止代码在运行时因缺少依赖而崩溃。

规则7：坦诚未知 (Honest Unknowns)

指令："如果 soulx-podcast 仓库中的某个实现过于复杂，或依赖了本地编译的 C++ 库（目前看似乎没有），AI 必须坦诚地指出这一点，并提出简化的替代方案（如示例代码中的 'Simple Monologue'），而不是幻想出一个无法运行的复杂实现。"

目的：减少幻觉，提供可落地的方案。